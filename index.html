<!DOCTYPE html>
<html>

<canvas id="canvas" height="800" width="800" style="border: 2px solid black" onclick="clicked()"></canvas>
<script>
    //"FRONTEND"--"FRONTEND"--"FRONTEND"--"FRONTEND"--"FRONTEND"--"FRONTEND"
    //creating canvas
    var c = document.getElementById("canvas");
    var ctx = c.getContext("2d");
    var boardsize = 8;
    //defines the color the player plays
    var color = "w"
    //setting canvas size
    c.width = 800;
    c.height = 800;
    //currentMove has the structure: currentMove[[mx_old, my_old], [mx_new, my_new], 0 or 1]
    const currentMove = [];
    //if canvas gets clicked we do the click function
    function clicked() {
        click()
        console.log("hsh");
    }
    window.addEventListener('mousemove', function (e) {
        mx = e.x;
        my = e.y;
    })



    function click() {
        //turns mouse coordinates into fields on board
        mx = (mx - mx % fieldsize) / fieldsize;
        my = (my - my % fieldsize) / fieldsize;
        //currentMove list has three values in it: 1.: the first field, 2.: the second field, 3.: 0 if no field was clicked before, 1 if a field was clicked
        //if a field was clicked
        //currentMove[2] != 0
        //set the clicked field as the second location in the list and submit the move
        if (currentMove[2] == 0) {
            currentMove[1] = [mx, my]
            clientPost(currentMove);
            //after submitting the move we set current Move back to 0, so you can play your next move
            currentMove[2] = 1
            //if no field was clicked before
            //clicked field is getting the first field, currentMove[2] is set to 1
            //next click the programm sets the next click as the second field
        } else {
            if (board[mx][my] != 0) {
                currentMove[0] = [mx, my]
                currentMove[2] = 0
            }
        }
    }

    //array where fields are listed [x][y],0=nothing, 1=pawn, 2=knight, 3=bishop,5=rook, 9=queen, 10=King
    const board = [];
    //generating an empty chessboard
    for (let x = 0; x < boardsize; x++) {
        const xy = []
        for (let y = 0; y < boardsize; y++) {
            xy[y] = 0;
        }
        board[x] = xy
    }
    //calculating the size of each field on the board in px
    var fieldsize = c.height / boardsize;
    //function that draws the field
    function gmupdt() {
        for (let x = 0; x < boardsize; x++) {
            for (let y = 0; y < boardsize; y++) {
                //makes normal fields black or white
                if ((x + y) % 2 != 0) {
                    ctx.fillStyle = "#AAAAAA";
                } else {
                    ctx.fillStyle = "#111111";
                }
                //pawn color
                if (board[x][y] == 1) {
                    ctx.fillStyle = "pink"
                }
                //knight color
                if (board[x][y] == 2) {
                    ctx.fillStyle = "green"
                }
                //bishops color
                if (board[x][y] == 3) {
                    ctx.fillStyle = "blue"
                }
                //rook color
                if (board[x][y] == 5) {
                    ctx.fillStyle = "red"
                }

                //queen color
                if (board[x][y] == 9) {
                    ctx.fillStyle = "purple"
                }

                //king color
                if (board[x][y] == 10) {
                    ctx.fillStyle = "yellow"
                }


                ctx.fillRect(fieldsize * x, fieldsize * y, fieldsize, fieldsize);

            }
        }
    }

    //server to client
    function serverPost(clmove) {
        //after getting told the legal moves by the server we play them on our local board
        board[clmove[1][0]][clmove[1][1]] = board[clmove[0][0]][clmove[0][1]]
        board[clmove[0][0]][clmove[0][1]] = 0
        gmupdt()
    }

    //"BACKEND"--"BACKEND"--"BACKEND"--"BACKEND"--"BACKEND"--"BACKEND
    const backendboard = board
    //clmove = clientmove (=CurrentMove)
    //that function detects when the frontend sends a move to the backend

    //client to server
    function clientPost(clmove) {
        const move = clmove
        //lets say the board is saved on the server from the view of white
        //that means if we play black we have to "flip our move by 180"
        if (color == "b") {
            //now were basically subtracting the coordinates of the fields from 7 flipping them around the center of the board
            for (let x = 0; a < 1; a++) {
                for (let y = 0; y < 1; y++) {
                    move[x][y] = 7 - move[x][y]
                }
            }
        }
        //now we have to check whether the move is possible
        //so first we figure out what kind of piece needs to be moved
        /*
            move[0][0] is the x coordinate of the first click
            move[0][1] is the y coordinate of the first click
            move[1][0] is the x coordinate of the second click
            move[1][1] is the y coordinate of the second click
        */

        switch (backendboard[move[0][0]][move[0][1]]){
            case 1: //pawn
            //checking if two coordinates have the same x-coordinate
            if (move[0][0] == move[1][0]) {
                //checks if piece y coordinate was changed
                if (move[0][1] == move [1][1]){
                    console.log("piece can't move to same position as before")
                    return;
                }else
                //this one checks how many moves to the front the pawn makes
                //if one move is made -> move
                //if two moves are made and pawn is on second rank -> move
                if (move[0][1] - 1 == move[1][1] || (move[0][1] == 6 && move[0][1] - 2 == move[1][1])) {
                    //now we change the board data in the backend and the frontend
                    serverPost(clmove);
                    backendboard[move[0][0]][move[0][1]] = 0
                    backendboard[move[1][0]][move[1][1]] = 1
                }
            }
            break;

            case 2: //knight
            if (((move[0][0] == move[1][0] - 1 || move[0][0] == move[1][0] + 1) && (move[0][1] == move[1][1] + 2 || move[0][1] == move[1][1] - 2)) || ((move[0][0] == move[1][0] - 2 || move[0][0] == move[1][0] + 2) && (move[0][1] == move[1][1] + 1 || move[0][1] == move[1][1] - 1))) {
                //if the programm comes this far, it means that the move is possible so we play it
                //check if frontend gives the same fields
                if (move[0][0] == move[1][0] && move[0][1] == move[1][1]) {
                    console.log("piece can't move to same position as before")
                    return;
                } else {
                    serverPost(clmove)
                    backendboard[move[0][0]][move[0][1]] = 0
                    backendboard[move[1][0]][move[1][1]] = 2
                }
            }
            break;

            case 3: //bishop
            if (backendboard[move[0][0]][move[0][1]] == 3) {
                if (Math.abs((move[0][0] - move[1][0])) == Math.abs((move[0][1] - move[1][1]))) {
                    if (move[0][0] == move[1][0] && move[0][1] == move[1][1]) {
                        console.log("piece can't move to same position as before")
                        return;
                    } else {
                        serverPost(clmove)
                        backendboard[move[0][0]][move[0][1]] = 0
                        backendboard[move[1][0]][move[1][1]] = 3
                    }
                }
            }
            break;

            case 9: //queen
            if (Math.abs((move[0][0] - move[1][0])) == Math.abs((move[0][1] - move[1][1])) || (move[0][0] == move[1][0]) || (move[0][1] == move[1][1])) {
                if (move[0][0] == move[1][0] && move[0][1] == move[1][1]) {
                    console.log("piece can't move to same position as before")
                    return;
                } else {
                    serverPost(clmove)
                    backendboard[move[0][0]][move[0][1]] = 0
                    backendboard[move[1][0]][move[1][1]] = 9
                }
            }
            break;

            case 10: //king
            if (Math.abs((move[0][0] - move[1][0])) <= 1 && Math.abs((move[0][1] - move[1][1])) <= 1) {
                if (move[0][0] == move[1][0] && move[0][1] == move[1][1]) {
                    console.log("piece can't move to same position as before")
                    return;
                } else {
                    serverPost(clmove)
                    backendboard[move[0][0]][move[0][1]] = 0
                    backendboard[move[1][0]][move[1][1]] = 10
                }
            }
            break;

            case 5://rook
                //check if clicked fields are same (in this case we terminate the backend process)
            if (move[0][0] == move[1][0] && move[0][1] == move[1][1]) {
                console.log("piece can't move to same position as before")
                return;
            } else {
                //check if can acually go on the field
                if (move[0][0] == move[1][0] || move[0][1] == move[1][1]) {
                    //check if any piece is on the way
                    if (move[0][0] == move[1][0]) {
                        for (let x = Math.min(move[0][1], move[1][1]) + 1; x < Math.max(move[0][1], move[1][1]); x++) {
                            if (backendboard[move[0][0]][x] != 0) {
                                console.log("piece in the way")
                                return;
                            }
                        }
                    }
                    if (move[0][1] == move[1][1]) {
                        for (let x = Math.min(move[0][0], move[1][0]) + 1; x < Math.max(move[0][0], move[1][0]); x++) {
                            if (backendboard[x][move[0][1]] != 0) {
                                console.log("piece in the way")
                                return;
                            }
                        }
                    }
                    serverPost(clmove)
                    backendboard[move[0][0]][move[0][1]] = 0
                    backendboard[move[1][0]][move[1][1]] = 5
                }
            }
            break;
        }
    }


    //1=pawn, 2=knight, 3=bishop,5=rook, 9=queen, 10=King
    board[1][7] = 9;
    board[5][7] = 5;
    board[2][6] = 10;
    board[3][6] = 1;
    board[5][0] = 2;
    board[6][1] = 3;

    gmupdt();




</script>

<p style="color:red">rook----red</p>
<p style="color:pink">pawn----pink</p>
<p style="color:green">knight----green</p>
<p style="color:blue">bishop----blue</p>
<p style="color:yellow">king----yellow</p>
<p style="color:purple">queen----purple</p>

</html>